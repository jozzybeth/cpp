# Урок 9: Умные указатели и управление памятью в C++

В этом уроке мы познакомимся с основами умных указателей, разберем их различия с сырыми указателями и научимся их использовать. Умные указатели существенно упрощают управление памятью и помогают избежать утечек памяти, что особенно важно при работе с многопоточными приложениями. В конце урока вы также найдете примеры типичных ошибок при работе с умными указателями, а в домашнем задании реализуете многопоточность для игры.

---

#### 1. Разница между сырыми указателями и умными указателями

**Сырые указатели** — это обычные указатели, которые просто хранят адрес объекта в памяти и требуют ручного управления этой памятью. Например:
```cpp
int* ptr = new int(10); // выделение памяти для целого числа
delete ptr;             // освобождение памяти
```
Основные проблемы сырых указателей:
- Риск утечек памяти, если забыть освободить память.
- Сложность управления временем жизни объекта.
- Риск двойного освобождения памяти.

**Умные указатели** — это специальные объекты, которые помогают управлять динамической памятью и автоматически освобождают её, когда она больше не нужна. Они представлены в стандартной библиотеке C++11 в виде классов `std::unique_ptr`, `std::shared_ptr` и `std::weak_ptr`.

#### 2. Виды умных указателей

1. **`std::unique_ptr`**: Указатель, который имеет эксклюзивное право владения объектом.
   - Не может быть скопирован, но может быть перемещен.
   - Автоматически удаляет объект, когда выходит из области видимости.
   - Подходит для ситуаций, когда один объект владеет ресурсом и никто другой не должен к нему обращаться.
   
   Пример:
   ```cpp
   #include <memory>

   void uniquePointerExample() {
       std::unique_ptr<int> ptr = std::make_unique<int>(10);
       std::cout << *ptr << std::endl; // выводит: 10
   } // ptr автоматически удалится здесь, и память освободится
   ```

2. **`std::shared_ptr`**: Указатель с разделяемым владением.
   - Может быть скопирован. Каждый `std::shared_ptr` увеличивает счетчик ссылок на объект.
   - Объект удаляется только тогда, когда последний `std::shared_ptr` на него уничтожается.
   - Полезен, когда несколько частей программы должны разделять владение объектом.

   Пример:
   ```cpp
   #include <memory>

   void sharedPointerExample() {
       std::shared_ptr<int> ptr1 = std::make_shared<int>(20);
       std::shared_ptr<int> ptr2 = ptr1; // копируем указатель, счетчик ссылок увеличивается
       std::cout << *ptr1 << std::endl; // выводит: 20
   } // объект удалится, когда ptr1 и ptr2 выйдут из области видимости
   ```

3. **`std::weak_ptr`**: Неконтролируемый (не увеличивающий счетчик) указатель на объект, управляемый `std::shared_ptr`.
   - Не влияет на время жизни объекта.
   - Может стать "висячим" указателем, если объект будет удален.
   - Полезен для избежания циклических зависимостей, когда объекты ссылаются друг на друга через `std::shared_ptr`.

   Пример:
   ```cpp
   #include <memory>

   void weakPointerExample() {
       std::shared_ptr<int> ptr1 = std::make_shared<int>(30);
       std::weak_ptr<int> weakPtr = ptr1; // создаем слабую ссылку

       if (auto lockedPtr = weakPtr.lock()) { // проверка на доступность
           std::cout << *lockedPtr << std::endl; // выводит: 30
       }
   } // объект удалится, когда ptr1 выйдет из области видимости
   ```

#### 3. Типичные ошибки при работе с умными указателями

1. **Попытка скопировать `std::unique_ptr`**: Поскольку `std::unique_ptr` не поддерживает копирование, попытка передать его по значению вызовет ошибку компиляции.
   ```cpp
   std::unique_ptr<int> ptr1 = std::make_unique<int>(40);
   // std::unique_ptr<int> ptr2 = ptr1; // ошибка: ptr1 не может быть скопирован
   ```

2. **Циклические ссылки с `std::shared_ptr`**: Если два объекта имеют `std::shared_ptr` друг на друга, они никогда не удалятся из-за взаимной ссылки. Решение — использовать `std::weak_ptr` для разрыва цикла.

3. **Попытка использовать `std::weak_ptr` после удаления объекта**: Поскольку `std::weak_ptr` не контролирует время жизни объекта, он может стать "висячим". Всегда проверяйте доступность объекта через метод `lock()`.

#### 4. Пример использования умных указателей в многопоточном приложении

Предположим, у нас есть класс, представляющий змейку в игре, и мы создаем два потока, чтобы управлять движением двух змей. Мы используем `std::shared_ptr` для разделяемого доступа к полю игры и `std::weak_ptr` для предотвращения циклических зависимостей.

```cpp
#include <iostream>
#include <memory>
#include <thread>
#include <mutex>
#include <vector>

class Snake {
public:
    Snake(int id) : id(id) {}
    void move() {
        std::cout << "Snake " << id << " moves." << std::endl;
    }
private:
    int id;
};

void runSnake(std::shared_ptr<Snake> snake, std::mutex& mtx) {
    while (true) {
        std::lock_guard<std::mutex> lock(mtx); // синхронизация
        snake->move();
        std::this_thread::sleep_for(std::chrono::milliseconds(500));
    }
}

int main() {
    auto snake1 = std::make_shared<Snake>(1);
    auto snake2 = std::make_shared<Snake>(2);

    std::mutex mtx; // мьютекс для синхронизации доступа к общим ресурсам

    std::thread thread1(runSnake, snake1, std::ref(mtx));
    std::thread thread2(runSnake, snake2, std::ref(mtx));

    thread1.join();
    thread2.join();

    return 0;
}
```

В этом примере:
- Каждый поток управляет своей змеей (`snake1` и `snake2`), что позволяет им двигаться одновременно.
- `std::mutex` используется для синхронизации доступа к общим ресурсам, таким как игровое поле.

# Домашнее задание: Добавление сложности и улучшенная многопоточность для игры Snake

#### Задача 3: Улучшение многопоточности и взаимодействия змей

В этом задании вы расширите функционал игры, добавив динамические препятствия и бонусные объекты, с которыми обе змейки могут взаимодействовать. Вы улучшите многопоточность, добавив отдельные потоки для обработки препятствий и бонусов, а также синхронизируете работу всех потоков. Эти изменения добавят игре новые интересные аспекты, требующие тщательной координации между потоками.

---

### Шаги выполнения

1. **Создание потоков для препятствий и бонусов**
   - Добавьте в игру **препятствия** — объекты, которые периодически появляются и исчезают на игровом поле.
   - Добавьте **бонусные объекты** — например, «яблоки», которые при сборе увеличивают длину змейки или дают другие преимущества.
   - Для обновления позиций препятствий и бонусов создайте отдельные потоки. Препятствия могут периодически изменять своё положение, а бонусные объекты могут появляться случайным образом на поле.

2. **Логика взаимодействия со змейками**
   - **Препятствия**: Если змея сталкивается с препятствием, игра заканчивается.
   - **Бонусные объекты**: Если змея собирает бонус, её длина увеличивается, и бонус исчезает. Бонус может приносить и другие эффекты (например, временное ускорение).
   - Взаимодействие с препятствиями и бонусами должно происходить в синхронизированной среде, чтобы избежать ошибок обновления состояния.

3. **Дополнительная логика управления для второй змейки**
   - Если вторая змейка управляется автоматически, добавьте ей способность реагировать на бонусные объекты (например, стремиться к ним, избегать препятствий).
   - Усовершенствуйте алгоритм движения так, чтобы автоматическая змейка могла динамически адаптироваться к изменениям на игровом поле (например, избегать внезапно появляющихся препятствий или реагировать на действия первой змейки).

4. **Синхронизация потоков**
   - Используйте `std::mutex` и `std::lock_guard` для управления доступом к общим ресурсам (игровому полю, координатам препятствий и бонусов).
   - Примените `std::condition_variable`, чтобы змейки и другие потоки могли быть уведомлены об изменениях на игровом поле (например, при появлении нового бонуса).
   - Обеспечьте корректное обновление состояния игрового поля без артефактов.

5. **Обработка коллизий с учетом новых элементов**
   - Реализуйте более сложную логику коллизий, учитывающую препятствия и бонусные объекты.
   - Обеспечьте корректное завершение игры при столкновении с препятствием или в случае, если змея сталкивается с другой змейкой.
   - При сборе бонусов добавьте логическое условие, чтобы бонусы корректно исчезали после сборки и не оказывали влияния на другие змейки.

6. **Плавная работа всех потоков**
   - Убедитесь, что потоки работают независимо и без блокировок. Для этого проведите оптимизацию кода, чтобы потоки не блокировали друг друга при обновлении игрового поля.
   - Сделайте проверку всех потоков на корректность работы, чтобы игра не «замораживалась» и не вызывала ошибок при одновременном доступе к объектам.

### Рекомендации по реализации

- Для потоков препятствий и бонусов используйте **асинхронные функции с задержками** (например, `std::this_thread::sleep_for`), чтобы обновления происходили через определенные промежутки времени.
- Для обработки бонусов и препятствий используйте **шаблон `Observer`** или подход с флагами/событиями, чтобы уведомлять змейку о появлении новых объектов.
- Настройте таймеры для каждого из потоков и задайте случайные интервалы появления/исчезновения объектов для большего реализма.
- Придерживайтесь **принципов инкапсуляции и разделения ответственности**, чтобы каждый класс (змейка, препятствия, бонусы) имел чёткие обязанности и интерфейс.

---

### Критерии выполнения

1. **Корректность многопоточности и синхронизации**
   - Все потоки (для змей, препятствий и бонусов) должны работать стабильно и не мешать друг другу.
   - Взаимодействие с игровым полем должно быть синхронизировано.

2. **Обработка коллизий и логика взаимодействия**
   - Логика взаимодействия должна корректно обрабатывать появление и исчезновение объектов.
   - Все события (сбор бонусов, столкновение с препятствием) должны обрабатываться корректно.

3. **Качество кода**
   - Код должен быть структурирован, с комментариями, объясняющими логику потоков и синхронизации.
   - Код должен быть читабельным и поддерживаемым, следуйте единообразному стилю и принципам SOLID.

---

### Deadline

26 ноября - требуется сделать Pull Request с полным функционалом и комментариями к измененным частям кода.

### Подсказки

- **Постепенная проверка**: тестируйте каждый новый элемент (добавление бонусов, препятствий, синхронизацию) отдельно.
- **Дебаггинг многопоточности**: используйте `std::cout` или логгирование для отслеживания выполнения потоков и проверки синхронизации.
- **Проверка артефактов**: при появлении артефактов в графике или лагов, используйте мьютексы и условные переменные для устранения проблем с одновременным доступом.
